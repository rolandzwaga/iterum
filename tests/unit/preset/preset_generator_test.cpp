// ==============================================================================
// Preset Generator Integration Tests
// ==============================================================================
// These tests verify that presets generated by preset_generator.cpp
// produce valid values when loaded by the actual params loaders.
//
// This catches:
// 1. Serialization order mismatches
// 2. Value scale mismatches (e.g., 0-100% vs 0-1)
// 3. Missing or extra fields
// ==============================================================================

#include <catch2/catch_all.hpp>
#include <vector>
#include <cstdint>
#include <cstring>

#include "base/source/fstreamer.h"
#include "pluginterfaces/base/ibstream.h"

// Include all params headers
#include "parameters/digital_params.h"
#include "parameters/shimmer_params.h"
#include "parameters/bbd_params.h"
#include "parameters/reverse_params.h"
#include "parameters/multitap_params.h"
#include "parameters/freeze_params.h"
#include "parameters/ducking_params.h"
#include "parameters/granular_params.h"
#include "parameters/spectral_params.h"
#include "parameters/tape_params.h"
#include "parameters/pingpong_params.h"

using namespace Iterum;

// ==============================================================================
// Test Helper: Simple IBStream implementation backed by a vector
// ==============================================================================

class VectorStream : public Steinberg::IBStream {
public:
    std::vector<uint8_t> data_;
    int64_t cursor_ = 0;
    uint32_t refCount_ = 1;

    Steinberg::tresult PLUGIN_API queryInterface(const Steinberg::TUID, void**) override {
        return Steinberg::kNotImplemented;
    }

    uint32_t PLUGIN_API addRef() override { return ++refCount_; }
    uint32_t PLUGIN_API release() override {
        if (--refCount_ == 0) { delete this; return 0; }
        return refCount_;
    }

    Steinberg::tresult PLUGIN_API read(void* buffer, Steinberg::int32 numBytes,
        Steinberg::int32* numBytesRead) override {
        if (cursor_ + numBytes > static_cast<int64_t>(data_.size())) {
            numBytes = static_cast<Steinberg::int32>(data_.size() - cursor_);
        }
        if (numBytes > 0) {
            std::memcpy(buffer, data_.data() + cursor_, numBytes);
            cursor_ += numBytes;
        }
        if (numBytesRead) *numBytesRead = numBytes;
        return Steinberg::kResultOk;
    }

    Steinberg::tresult PLUGIN_API write(void* buffer, Steinberg::int32 numBytes,
        Steinberg::int32* numBytesWritten) override {
        const auto* bytes = static_cast<const uint8_t*>(buffer);
        for (Steinberg::int32 i = 0; i < numBytes; ++i) {
            if (cursor_ >= static_cast<int64_t>(data_.size())) {
                data_.push_back(bytes[i]);
            } else {
                data_[static_cast<size_t>(cursor_)] = bytes[i];
            }
            cursor_++;
        }
        if (numBytesWritten) *numBytesWritten = numBytes;
        return Steinberg::kResultOk;
    }

    Steinberg::tresult PLUGIN_API seek(Steinberg::int64 pos, Steinberg::int32 mode,
        Steinberg::int64* result) override {
        switch (mode) {
            case kIBSeekSet: cursor_ = pos; break;
            case kIBSeekCur: cursor_ += pos; break;
            case kIBSeekEnd: cursor_ = static_cast<int64_t>(data_.size()) + pos; break;
        }
        if (result) *result = cursor_;
        return Steinberg::kResultOk;
    }

    Steinberg::tresult PLUGIN_API tell(Steinberg::int64* pos) override {
        if (pos) *pos = cursor_;
        return Steinberg::kResultOk;
    }
};

// ==============================================================================
// Binary Writer (EXACT COPY from preset_generator.cpp)
// ==============================================================================

class BinaryWriter {
public:
    std::vector<uint8_t> data;

    void writeInt32(int32_t val) {
        auto bytes = reinterpret_cast<const uint8_t*>(&val);
        data.insert(data.end(), bytes, bytes + 4);
    }

    void writeFloat(float val) {
        auto bytes = reinterpret_cast<const uint8_t*>(&val);
        data.insert(data.end(), bytes, bytes + 4);
    }
};

// ==============================================================================
// Preset Structs (EXACT COPY from preset_generator.cpp)
// These MUST match preset_generator.cpp exactly!
// ==============================================================================

struct GranularPreset {
    float grainSize = 100.0f;
    float density = 10.0f;
    float delayTime = 200.0f;
    float pitch = 0.0f;
    float pitchSpray = 0.0f;
    float positionSpray = 0.0f;
    float panSpray = 0.0f;
    float reverseProb = 0.0f;
    int freeze = 0;
    float feedback = 0.0f;
    float dryWet = 0.5f;            // 0-1 (fixed)
    int envelopeType = 1;
    int timeMode = 0;
    int noteValue = 4;
    float jitter = 0.0f;
    int pitchQuantMode = 0;
    float texture = 0.5f;
    float stereoWidth = 0.5f;
};

struct SpectralPreset {
    int fftSize = 1024;
    float baseDelay = 250.0f;
    float spread = 0.0f;
    int spreadDirection = 0;
    float feedback = 0.0f;
    float feedbackTilt = 0.0f;
    int freeze = 0;
    float diffusion = 0.0f;
    float dryWet = 50.0f;           // OK: params expects 0-100%
    int spreadCurve = 0;
    float stereoWidth = 0.0f;
    int timeMode = 0;
    int noteValue = 4;
};

struct ShimmerPreset {
    float delayTime = 500.0f;
    float pitchSemitones = 12.0f;
    float pitchCents = 0.0f;
    float shimmerMix = 100.0f;
    float feedback = 0.5f;
    float diffusionAmount = 50.0f;
    float diffusionSize = 50.0f;
    int filterEnabled = 0;
    float filterCutoff = 4000.0f;
    float dryWet = 50.0f;           // OK: params expects 0-100%
    int timeMode = 0;
    int noteValue = 4;
};

struct TapePreset {
    float motorSpeed = 1.0f;
    float motorInertia = 0.5f;
    float wear = 0.0f;
    float saturation = 0.0f;
    float age = 0.0f;
    int spliceEnabled = 0;
    float spliceIntensity = 0.5f;
    float feedback = 0.3f;
    float mix = 0.5f;               // 0-1 (fixed)
    int head1Enabled = 1;
    float head1Level = 1.0f;
    float head1Pan = 0.0f;
    int head2Enabled = 0;
    float head2Level = 0.7f;
    float head2Pan = -0.5f;
    int head3Enabled = 0;
    float head3Level = 0.5f;
    float head3Pan = 0.5f;
};

struct BBDPreset {
    float delayTime = 300.0f;
    float feedback = 0.4f;
    float modulationDepth = 0.3f;
    float modulationRate = 0.5f;
    float age = 0.3f;
    int era = 1;
    float mix = 0.5f;               // 0-1 (fixed)
    int timeMode = 0;
    int noteValue = 4;
};

struct DigitalPreset {
    float delayTime = 500.0f;
    int timeMode = 1;
    int noteValue = 4;
    float feedback = 0.4f;
    int limiterCharacter = 1;
    int era = 2;
    float age = 0.0f;
    float modulationDepth = 0.0f;
    float modulationRate = 1.0f;
    int modulationWaveform = 0;
    float mix = 0.5f;               // 0-1 (fixed)
    float width = 100.0f;
};

struct PingPongPreset {
    float delayTime = 500.0f;
    int timeMode = 1;
    int noteValue = 4;
    int lrRatio = 0;
    float feedback = 0.5f;
    float crossFeedback = 1.0f;
    float width = 100.0f;
    float modulationDepth = 0.0f;
    float modulationRate = 1.0f;
    float mix = 0.5f;               // OK: correct scale
};

struct ReversePreset {
    float chunkSize = 500.0f;
    float crossfade = 50.0f;
    int playbackMode = 0;
    float feedback = 0.0f;
    int filterEnabled = 0;
    float filterCutoff = 4000.0f;
    int filterType = 0;
    float dryWet = 0.5f;            // OK: correct scale
    int timeMode = 0;
    int noteValue = 4;
};

struct MultiTapPreset {
    int timingPattern = 2;
    int spatialPattern = 2;
    int tapCount = 4;
    float baseTime = 500.0f;
    float tempo = 120.0f;
    float feedback = 0.5f;
    float feedbackLPCutoff = 20000.0f;
    float feedbackHPCutoff = 20.0f;
    float morphTime = 500.0f;
    float dryWet = 50.0f;           // OK: params expects 0-100%
    int timeMode = 0;
    int noteValue = 4;
};

struct FreezePreset {
    int freezeEnabled = 0;
    float delayTime = 500.0f;
    float feedback = 0.5f;
    float pitchSemitones = 0.0f;
    float pitchCents = 0.0f;
    float shimmerMix = 0.0f;
    float decay = 0.5f;
    float diffusionAmount = 0.3f;
    float diffusionSize = 0.5f;
    int filterEnabled = 0;
    int filterType = 0;
    float filterCutoff = 1000.0f;
    float dryWet = 0.5f;            // OK: correct scale
    int timeMode = 0;
    int noteValue = 4;
};

struct DuckingPreset {
    int duckingEnabled = 1;
    float threshold = -30.0f;
    float duckAmount = 50.0f;
    float attackTime = 10.0f;
    float releaseTime = 200.0f;
    float holdTime = 50.0f;
    int duckTarget = 0;
    int sidechainFilterEnabled = 0;
    float sidechainFilterCutoff = 80.0f;
    float delayTime = 500.0f;
    float feedback = 0.0f;
    float dryWet = 50.0f;           // OK: params expects 0-100%
    int timeMode = 0;
    int noteValue = 4;
};

// ==============================================================================
// Write Functions (EXACT COPY from preset_generator.cpp)
// ==============================================================================

void writeGranularState(BinaryWriter& w, const GranularPreset& p) {
    w.writeFloat(p.grainSize);
    w.writeFloat(p.density);
    w.writeFloat(p.delayTime);
    w.writeFloat(p.pitch);
    w.writeFloat(p.pitchSpray);
    w.writeFloat(p.positionSpray);
    w.writeFloat(p.panSpray);
    w.writeFloat(p.reverseProb);
    w.writeInt32(p.freeze);
    w.writeFloat(p.feedback);
    w.writeFloat(p.dryWet);
    w.writeInt32(p.envelopeType);
    w.writeInt32(p.timeMode);
    w.writeInt32(p.noteValue);
    w.writeFloat(p.jitter);
    w.writeInt32(p.pitchQuantMode);
    w.writeFloat(p.texture);
    w.writeFloat(p.stereoWidth);
}

void writeSpectralState(BinaryWriter& w, const SpectralPreset& p) {
    w.writeInt32(p.fftSize);
    w.writeFloat(p.baseDelay);
    w.writeFloat(p.spread);
    w.writeInt32(p.spreadDirection);
    w.writeFloat(p.feedback);
    w.writeFloat(p.feedbackTilt);
    w.writeInt32(p.freeze);
    w.writeFloat(p.diffusion);
    w.writeFloat(p.dryWet);
    w.writeInt32(p.spreadCurve);
    w.writeFloat(p.stereoWidth);
    w.writeInt32(p.timeMode);
    w.writeInt32(p.noteValue);
}

void writeShimmerState(BinaryWriter& w, const ShimmerPreset& p) {
    w.writeFloat(p.delayTime);
    w.writeInt32(p.timeMode);
    w.writeInt32(p.noteValue);
    w.writeFloat(p.pitchSemitones);
    w.writeFloat(p.pitchCents);
    w.writeFloat(p.shimmerMix);
    w.writeFloat(p.feedback);
    w.writeFloat(p.diffusionAmount);
    w.writeFloat(p.diffusionSize);
    w.writeInt32(p.filterEnabled);
    w.writeFloat(p.filterCutoff);
    w.writeFloat(p.dryWet);
}

void writeTapeState(BinaryWriter& w, const TapePreset& p) {
    w.writeFloat(p.motorSpeed);
    w.writeFloat(p.motorInertia);
    w.writeFloat(p.wear);
    w.writeFloat(p.saturation);
    w.writeFloat(p.age);
    w.writeInt32(p.spliceEnabled);
    w.writeFloat(p.spliceIntensity);
    w.writeFloat(p.feedback);
    w.writeFloat(p.mix);
    // Head enables (grouped)
    w.writeInt32(p.head1Enabled);
    w.writeInt32(p.head2Enabled);
    w.writeInt32(p.head3Enabled);
    // Head levels (grouped)
    w.writeFloat(p.head1Level);
    w.writeFloat(p.head2Level);
    w.writeFloat(p.head3Level);
    // Head pans (grouped)
    w.writeFloat(p.head1Pan);
    w.writeFloat(p.head2Pan);
    w.writeFloat(p.head3Pan);
}

void writeBBDState(BinaryWriter& w, const BBDPreset& p) {
    // Order MUST match bbd_params.h saveBBDParams()
    w.writeFloat(p.delayTime);
    w.writeInt32(p.timeMode);
    w.writeInt32(p.noteValue);
    w.writeFloat(p.feedback);
    w.writeFloat(p.modulationDepth);
    w.writeFloat(p.modulationRate);
    w.writeFloat(p.age);
    w.writeInt32(p.era);
    w.writeFloat(p.mix);
}

void writeDigitalState(BinaryWriter& w, const DigitalPreset& p) {
    w.writeFloat(p.delayTime);
    w.writeInt32(p.timeMode);
    w.writeInt32(p.noteValue);
    w.writeFloat(p.feedback);
    w.writeInt32(p.limiterCharacter);
    w.writeInt32(p.era);
    w.writeFloat(p.age);
    w.writeFloat(p.modulationDepth);
    w.writeFloat(p.modulationRate);
    w.writeInt32(p.modulationWaveform);
    w.writeFloat(p.mix);
    w.writeFloat(p.width);
}

void writePingPongState(BinaryWriter& w, const PingPongPreset& p) {
    w.writeFloat(p.delayTime);
    w.writeInt32(p.timeMode);
    w.writeInt32(p.noteValue);
    w.writeInt32(p.lrRatio);
    w.writeFloat(p.feedback);
    w.writeFloat(p.crossFeedback);
    w.writeFloat(p.width);
    w.writeFloat(p.modulationDepth);
    w.writeFloat(p.modulationRate);
    w.writeFloat(p.mix);
}

void writeReverseState(BinaryWriter& w, const ReversePreset& p) {
    w.writeFloat(p.chunkSize);
    w.writeInt32(p.timeMode);
    w.writeInt32(p.noteValue);
    w.writeFloat(p.crossfade);
    w.writeInt32(p.playbackMode);
    w.writeFloat(p.feedback);
    w.writeInt32(p.filterEnabled);
    w.writeFloat(p.filterCutoff);
    w.writeInt32(p.filterType);
    w.writeFloat(p.dryWet);
}

void writeMultiTapState(BinaryWriter& w, const MultiTapPreset& p) {
    w.writeInt32(p.timeMode);
    w.writeInt32(p.noteValue);
    w.writeInt32(p.timingPattern);
    w.writeInt32(p.spatialPattern);
    w.writeInt32(p.tapCount);
    w.writeFloat(p.baseTime);
    w.writeFloat(p.tempo);
    w.writeFloat(p.feedback);
    w.writeFloat(p.feedbackLPCutoff);
    w.writeFloat(p.feedbackHPCutoff);
    w.writeFloat(p.morphTime);
    w.writeFloat(p.dryWet);
}

void writeFreezeState(BinaryWriter& w, const FreezePreset& p) {
    w.writeInt32(p.freezeEnabled);
    w.writeFloat(p.delayTime);
    w.writeInt32(p.timeMode);
    w.writeInt32(p.noteValue);
    w.writeFloat(p.feedback);
    w.writeFloat(p.pitchSemitones);
    w.writeFloat(p.pitchCents);
    w.writeFloat(p.shimmerMix);
    w.writeFloat(p.decay);
    w.writeFloat(p.diffusionAmount);
    w.writeFloat(p.diffusionSize);
    w.writeInt32(p.filterEnabled);
    w.writeInt32(p.filterType);
    w.writeFloat(p.filterCutoff);
    w.writeFloat(p.dryWet);
}

void writeDuckingState(BinaryWriter& w, const DuckingPreset& p) {
    w.writeInt32(p.duckingEnabled);
    w.writeFloat(p.threshold);
    w.writeFloat(p.duckAmount);
    w.writeFloat(p.attackTime);
    w.writeFloat(p.releaseTime);
    w.writeFloat(p.holdTime);
    w.writeInt32(p.duckTarget);
    w.writeInt32(p.sidechainFilterEnabled);
    w.writeFloat(p.sidechainFilterCutoff);
    w.writeFloat(p.delayTime);
    w.writeInt32(p.timeMode);
    w.writeInt32(p.noteValue);
    w.writeFloat(p.feedback);
    w.writeFloat(p.dryWet);
}

// ==============================================================================
// Helper to create IBStreamer from BinaryWriter data
// ==============================================================================

Steinberg::IBStreamer createStreamerFromData(VectorStream& stream, const std::vector<uint8_t>& data) {
    stream.data_ = data;
    stream.cursor_ = 0;
    return Steinberg::IBStreamer(&stream, kLittleEndian);
}

// ==============================================================================
// VALUE RANGE TESTS
// These tests verify that preset values are in the ranges expected by params files
// ==============================================================================

TEST_CASE("Digital preset values are in valid ranges", "[preset][digital][ranges]") {
    // Use default preset values from preset_generator.cpp
    DigitalPreset preset;

    BinaryWriter writer;
    writeDigitalState(writer, preset);

    VectorStream stream;
    auto streamer = createStreamerFromData(stream, writer.data);

    DigitalParams params;
    loadDigitalParams(params, streamer);

    // Verify all values are in expected ranges
    REQUIRE(params.delayTime.load() >= 1.0f);
    REQUIRE(params.delayTime.load() <= 10000.0f);

    REQUIRE(params.timeMode.load() >= 0);
    REQUIRE(params.timeMode.load() <= 1);

    REQUIRE(params.noteValue.load() >= 0);
    REQUIRE(params.noteValue.load() <= 9);

    REQUIRE(params.feedback.load() >= 0.0f);
    REQUIRE(params.feedback.load() <= 1.2f);

    REQUIRE(params.limiterCharacter.load() >= 0);
    REQUIRE(params.limiterCharacter.load() <= 2);

    REQUIRE(params.era.load() >= 0);
    REQUIRE(params.era.load() <= 2);

    REQUIRE(params.age.load() >= 0.0f);
    REQUIRE(params.age.load() <= 1.0f);

    REQUIRE(params.modulationDepth.load() >= 0.0f);
    REQUIRE(params.modulationDepth.load() <= 1.0f);

    REQUIRE(params.modulationRate.load() >= 0.1f);
    REQUIRE(params.modulationRate.load() <= 10.0f);

    REQUIRE(params.modulationWaveform.load() >= 0);
    REQUIRE(params.modulationWaveform.load() <= 5);

    // THIS IS THE CRITICAL CHECK - mix must be 0-1, not 0-100
    REQUIRE(params.mix.load() >= 0.0f);
    REQUIRE(params.mix.load() <= 1.0f);

    REQUIRE(params.width.load() >= 0.0f);
    REQUIRE(params.width.load() <= 200.0f);
}

TEST_CASE("Granular preset values are in valid ranges", "[preset][granular][ranges]") {
    GranularPreset preset;

    BinaryWriter writer;
    writeGranularState(writer, preset);

    VectorStream stream;
    auto streamer = createStreamerFromData(stream, writer.data);

    GranularParams params;
    loadGranularParams(params, streamer);

    REQUIRE(params.grainSize.load() >= 5.0f);
    REQUIRE(params.grainSize.load() <= 500.0f);

    REQUIRE(params.density.load() >= 1.0f);
    REQUIRE(params.density.load() <= 50.0f);

    REQUIRE(params.delayTime.load() >= 0.0f);
    REQUIRE(params.delayTime.load() <= 5000.0f);

    REQUIRE(params.feedback.load() >= 0.0f);
    REQUIRE(params.feedback.load() <= 1.2f);

    // THIS IS THE CRITICAL CHECK - dryWet must be 0-1, not 0-100
    REQUIRE(params.dryWet.load() >= 0.0f);
    REQUIRE(params.dryWet.load() <= 1.0f);

    REQUIRE(params.stereoWidth.load() >= 0.0f);
    REQUIRE(params.stereoWidth.load() <= 1.0f);
}

TEST_CASE("Tape preset values are in valid ranges", "[preset][tape][ranges]") {
    TapePreset preset;

    BinaryWriter writer;
    writeTapeState(writer, preset);

    VectorStream stream;
    auto streamer = createStreamerFromData(stream, writer.data);

    TapeParams params;
    loadTapeParams(params, streamer);

    REQUIRE(params.motorSpeed.load() >= 0.5f);
    REQUIRE(params.motorSpeed.load() <= 2.0f);

    REQUIRE(params.motorInertia.load() >= 0.0f);
    REQUIRE(params.motorInertia.load() <= 1.0f);

    REQUIRE(params.wear.load() >= 0.0f);
    REQUIRE(params.wear.load() <= 1.0f);

    REQUIRE(params.feedback.load() >= 0.0f);
    REQUIRE(params.feedback.load() <= 1.2f);

    // THIS IS THE CRITICAL CHECK - mix must be 0-1, not 0-100
    REQUIRE(params.mix.load() >= 0.0f);
    REQUIRE(params.mix.load() <= 1.0f);

    REQUIRE(params.head1Level.load() >= 0.0f);
    REQUIRE(params.head1Level.load() <= 1.0f);

    REQUIRE(params.head1Pan.load() >= -1.0f);
    REQUIRE(params.head1Pan.load() <= 1.0f);
}

TEST_CASE("BBD preset values are in valid ranges", "[preset][bbd][ranges]") {
    BBDPreset preset;

    BinaryWriter writer;
    writeBBDState(writer, preset);

    VectorStream stream;
    auto streamer = createStreamerFromData(stream, writer.data);

    BBDParams params;
    loadBBDParams(params, streamer);

    REQUIRE(params.delayTime.load() >= 1.0f);
    REQUIRE(params.delayTime.load() <= 1000.0f);

    REQUIRE(params.feedback.load() >= 0.0f);
    REQUIRE(params.feedback.load() <= 1.2f);

    REQUIRE(params.modulationDepth.load() >= 0.0f);
    REQUIRE(params.modulationDepth.load() <= 1.0f);

    REQUIRE(params.modulationRate.load() >= 0.1f);
    REQUIRE(params.modulationRate.load() <= 10.0f);

    REQUIRE(params.age.load() >= 0.0f);
    REQUIRE(params.age.load() <= 1.0f);

    REQUIRE(params.era.load() >= 0);
    REQUIRE(params.era.load() <= 2);

    // THIS IS THE CRITICAL CHECK - mix must be 0-1, not 0-100
    REQUIRE(params.mix.load() >= 0.0f);
    REQUIRE(params.mix.load() <= 1.0f);
}

TEST_CASE("Shimmer preset values are in valid ranges", "[preset][shimmer][ranges]") {
    ShimmerPreset preset;

    BinaryWriter writer;
    writeShimmerState(writer, preset);

    VectorStream stream;
    auto streamer = createStreamerFromData(stream, writer.data);

    ShimmerParams params;
    loadShimmerParams(params, streamer);

    REQUIRE(params.delayTime.load() >= 1.0f);
    REQUIRE(params.delayTime.load() <= 5000.0f);

    REQUIRE(params.pitchSemitones.load() >= -24.0f);
    REQUIRE(params.pitchSemitones.load() <= 24.0f);

    REQUIRE(params.feedback.load() >= 0.0f);
    REQUIRE(params.feedback.load() <= 1.2f);

    // Shimmer dryWet is 0-100%
    REQUIRE(params.dryWet.load() >= 0.0f);
    REQUIRE(params.dryWet.load() <= 100.0f);
}

TEST_CASE("Spectral preset values are in valid ranges", "[preset][spectral][ranges]") {
    SpectralPreset preset;

    BinaryWriter writer;
    writeSpectralState(writer, preset);

    VectorStream stream;
    auto streamer = createStreamerFromData(stream, writer.data);

    SpectralParams params;
    loadSpectralParams(params, streamer);

    REQUIRE(params.fftSize.load() >= 256);
    REQUIRE(params.fftSize.load() <= 8192);

    REQUIRE(params.baseDelay.load() >= 0.0f);
    REQUIRE(params.baseDelay.load() <= 5000.0f);

    REQUIRE(params.feedback.load() >= 0.0f);
    REQUIRE(params.feedback.load() <= 1.0f);

    // Spectral dryWet is 0-100%
    REQUIRE(params.dryWet.load() >= 0.0f);
    REQUIRE(params.dryWet.load() <= 100.0f);
}

TEST_CASE("PingPong preset values are in valid ranges", "[preset][pingpong][ranges]") {
    PingPongPreset preset;

    BinaryWriter writer;
    writePingPongState(writer, preset);

    VectorStream stream;
    auto streamer = createStreamerFromData(stream, writer.data);

    PingPongParams params;
    loadPingPongParams(params, streamer);

    REQUIRE(params.delayTime.load() >= 1.0f);
    REQUIRE(params.delayTime.load() <= 5000.0f);

    REQUIRE(params.feedback.load() >= 0.0f);
    REQUIRE(params.feedback.load() <= 1.2f);

    // PingPong mix is 0-1
    REQUIRE(params.mix.load() >= 0.0f);
    REQUIRE(params.mix.load() <= 1.0f);

    REQUIRE(params.width.load() >= 0.0f);
    REQUIRE(params.width.load() <= 200.0f);
}

TEST_CASE("Reverse preset values are in valid ranges", "[preset][reverse][ranges]") {
    ReversePreset preset;

    BinaryWriter writer;
    writeReverseState(writer, preset);

    VectorStream stream;
    auto streamer = createStreamerFromData(stream, writer.data);

    ReverseParams params;
    loadReverseParams(params, streamer);

    REQUIRE(params.chunkSize.load() >= 50.0f);
    REQUIRE(params.chunkSize.load() <= 2000.0f);

    REQUIRE(params.feedback.load() >= 0.0f);
    REQUIRE(params.feedback.load() <= 1.0f);

    // Reverse dryWet is 0-1
    REQUIRE(params.dryWet.load() >= 0.0f);
    REQUIRE(params.dryWet.load() <= 1.0f);
}

TEST_CASE("MultiTap preset values are in valid ranges", "[preset][multitap][ranges]") {
    MultiTapPreset preset;

    BinaryWriter writer;
    writeMultiTapState(writer, preset);

    VectorStream stream;
    auto streamer = createStreamerFromData(stream, writer.data);

    MultiTapParams params;
    loadMultiTapParams(params, streamer);

    REQUIRE(params.timingPattern.load() >= 0);
    REQUIRE(params.timingPattern.load() <= 19);

    REQUIRE(params.tapCount.load() >= 2);
    REQUIRE(params.tapCount.load() <= 16);

    REQUIRE(params.feedback.load() >= 0.0f);
    REQUIRE(params.feedback.load() <= 1.1f);

    // MultiTap dryWet is 0-100%
    REQUIRE(params.dryWet.load() >= 0.0f);
    REQUIRE(params.dryWet.load() <= 100.0f);
}

TEST_CASE("Freeze preset values are in valid ranges", "[preset][freeze][ranges]") {
    FreezePreset preset;

    BinaryWriter writer;
    writeFreezeState(writer, preset);

    VectorStream stream;
    auto streamer = createStreamerFromData(stream, writer.data);

    FreezeParams params;
    loadFreezeParams(params, streamer);

    REQUIRE(params.delayTime.load() >= 1.0f);
    REQUIRE(params.delayTime.load() <= 5000.0f);

    REQUIRE(params.feedback.load() >= 0.0f);
    REQUIRE(params.feedback.load() <= 1.0f);

    // Freeze dryWet is 0-1
    REQUIRE(params.dryWet.load() >= 0.0f);
    REQUIRE(params.dryWet.load() <= 1.0f);
}

TEST_CASE("Ducking preset values are in valid ranges", "[preset][ducking][ranges]") {
    DuckingPreset preset;

    BinaryWriter writer;
    writeDuckingState(writer, preset);

    VectorStream stream;
    auto streamer = createStreamerFromData(stream, writer.data);

    DuckingParams params;
    loadDuckingParams(params, streamer);

    REQUIRE(params.threshold.load() >= -60.0f);
    REQUIRE(params.threshold.load() <= 0.0f);

    REQUIRE(params.duckAmount.load() >= 0.0f);
    REQUIRE(params.duckAmount.load() <= 100.0f);

    REQUIRE(params.feedback.load() >= 0.0f);
    REQUIRE(params.feedback.load() <= 1.0f);

    // Ducking dryWet is 0-100%
    REQUIRE(params.dryWet.load() >= 0.0f);
    REQUIRE(params.dryWet.load() <= 100.0f);
}
